package gnu.kawa.functions;

import gnu.kawa.format.ReportFormat;
import java.io.IOException;
import java.text.FieldPosition;
import java.text.Format;















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































class LispIterationFormat
  extends ReportFormat
{
  int maxIterations;
  boolean seenAt;
  boolean seenColon;
  boolean atLeastOnce;
  Format body;
  
  LispIterationFormat() {}
  
  public static int format(Format body, int maxIterations, Object[] args, int start, Appendable dst, boolean seenColon, boolean atLeastOnce)
    throws IOException
  {
    for (int i = 0; 
        
        (i != maxIterations) || (maxIterations == -1); i++)
    {


      if ((start == args.length) && ((i > 0) || (!atLeastOnce)))
        break;
      if (seenColon)
      {
        Object curArg = args[start];
        Object[] curArr = LispFormat.asArray(curArg);
        if (curArr == null) {}
        

        int result = ReportFormat.format(body, curArr, 0, dst, null);
        start++;
        if (ReportFormat.resultCode(result) == 242) {
          break;
        }
      }
      else {
        start = ReportFormat.format(body, args, start, dst, null);
        if (start < 0)
        {
          start = ReportFormat.nextArg(start);
          break;
        }
      }
    }
    return start;
  }
  
  public int format(Object[] args, int start, Appendable dst, FieldPosition fpos)
    throws IOException
  {
    int maxIterations = getParam(this.maxIterations, -1, args, start);
    
    if (this.maxIterations == -1610612736) { start++;
    }
    Format body = this.body;
    if (body == null)
    {

      Object arg = args[(start++)];
      if ((arg instanceof Format)) {
        body = (Format)arg;
      }
      else {
        try
        {
          body = new LispFormat(arg.toString());
        }
        catch (Exception ex)
        {
          dst.append("<invalid argument for \"\" format>");
          return args.length;
        }
      }
    }
    if (seenAt)
    {
      return format(body, maxIterations, args, start, dst, seenColon, atLeastOnce);
    }
    


    Object arg = args[start];
    Object[] curArgs = LispFormat.asArray(arg);
    if (curArgs == null)
    {
      dst.append('{');
      dst.append(arg.toString());
      dst.append('}');
    }
    else {
      format(body, maxIterations, curArgs, 0, dst, seenColon, atLeastOnce);
    }
    return start + 1;
  }
  

  public String toString()
  {
    StringBuffer sbuf = new StringBuffer();
    sbuf.append("LispIterationFormat[");
    sbuf.append(body);
    sbuf.append("]");
    return sbuf.toString();
  }
}
