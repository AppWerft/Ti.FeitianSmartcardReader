/*
 * Decompiled with CFR 0.139.
 */
package kawa.lib.scheme;

import gnu.expr.ModuleBody;
import gnu.expr.ModuleInfo;
import gnu.kawa.reflect.StaticFieldLocation;
import gnu.lists.Consumer;
import gnu.mapping.CallContext;

/*
 * Illegal identifiers - consider using --renameillegalidents true
 */
public class base
extends ModuleBody {
    public static final StaticFieldLocation bytevector$Qu;
    public static final StaticFieldLocation make$Mnbytevector;
    public static final StaticFieldLocation bytevector$Mnlength;
    public static final StaticFieldLocation bytevector$Mnu8$Mnref;
    public static final StaticFieldLocation bytevector$Mnu8$Mnset$Ex;
    public static final StaticFieldLocation bytevector$Mncopy;
    public static final StaticFieldLocation bytevector$Mncopy$Ex;
    public static final StaticFieldLocation bytevector$Mnappend;
    public static final StaticFieldLocation utf8$Mn$Grstring;
    public static final StaticFieldLocation string$Mn$Grutf8;
    public static final StaticFieldLocation case;
    public static final StaticFieldLocation char$Qu;
    public static final StaticFieldLocation char$Mn$Grinteger;
    public static final StaticFieldLocation integer$Mn$Grchar;
    public static final StaticFieldLocation with$Mnexception$Mnhandler;
    public static final StaticFieldLocation raise;
    public static final StaticFieldLocation raise$Mncontinuable;
    public static final StaticFieldLocation guard;
    public static final StaticFieldLocation error;
    public static final StaticFieldLocation error$Mnobject$Qu;
    public static final StaticFieldLocation error$Mnobject$Mnmessage;
    public static final StaticFieldLocation error$Mnobject$Mnirritants;
    public static final StaticFieldLocation read$Mnerror$Qu;
    public static final StaticFieldLocation file$Mnerror$Qu;
    public static final StaticFieldLocation pair$Qu;
    public static final StaticFieldLocation cons;
    public static final StaticFieldLocation null$Qu;
    public static final StaticFieldLocation set$Mncar$Ex;
    public static final StaticFieldLocation set$Mncdr$Ex;
    public static final StaticFieldLocation car;
    public static final StaticFieldLocation cdr;
    public static final StaticFieldLocation caar;
    public static final StaticFieldLocation cadr;
    public static final StaticFieldLocation cdar;
    public static final StaticFieldLocation cddr;
    public static final StaticFieldLocation length;
    public static final StaticFieldLocation reverse;
    public static final StaticFieldLocation list$Mntail;
    public static final StaticFieldLocation list$Mnref;
    public static final StaticFieldLocation list$Mnset$Ex;
    public static final StaticFieldLocation list$Qu;
    public static final StaticFieldLocation make$Mnlist;
    public static final StaticFieldLocation memq;
    public static final StaticFieldLocation memv;
    public static final StaticFieldLocation member;
    public static final StaticFieldLocation assq;
    public static final StaticFieldLocation assv;
    public static final StaticFieldLocation assoc;
    public static final StaticFieldLocation list$Mncopy;
    public static final StaticFieldLocation boolean$Qu;
    public static final StaticFieldLocation boolean$Eq$Qu;
    public static final StaticFieldLocation symbol$Qu;
    public static final StaticFieldLocation symbol$Mn$Grstring;
    public static final StaticFieldLocation symbol$Eq$Qu;
    public static final StaticFieldLocation string$Mn$Grsymbol;
    public static final StaticFieldLocation procedure$Qu;
    public static final StaticFieldLocation values;
    public static final StaticFieldLocation dynamic$Mnwind;
    public static final StaticFieldLocation features;
    public static final StaticFieldLocation number$Qu;
    public static final StaticFieldLocation complex$Qu;
    public static final StaticFieldLocation real$Qu;
    public static final StaticFieldLocation rational$Qu;
    public static final StaticFieldLocation integer$Qu;
    public static final StaticFieldLocation exact$Mninteger$Qu;
    public static final StaticFieldLocation exact$Qu;
    public static final StaticFieldLocation inexact$Qu;
    public static final StaticFieldLocation zero$Qu;
    public static final StaticFieldLocation positive$Qu;
    public static final StaticFieldLocation negative$Qu;
    public static final StaticFieldLocation max;
    public static final StaticFieldLocation min;
    public static final StaticFieldLocation abs;
    public static final StaticFieldLocation floor$Sl;
    public static final StaticFieldLocation truncate$Sl;
    public static final StaticFieldLocation gcd;
    public static final StaticFieldLocation lcm;
    public static final StaticFieldLocation numerator;
    public static final StaticFieldLocation denominator;
    public static final StaticFieldLocation floor;
    public static final StaticFieldLocation ceiling;
    public static final StaticFieldLocation truncate;
    public static final StaticFieldLocation round;
    public static final StaticFieldLocation rationalize;
    public static final StaticFieldLocation square;
    public static final StaticFieldLocation inexact;
    public static final StaticFieldLocation exact;
    public static final StaticFieldLocation number$Mn$Grstring;
    public static final StaticFieldLocation string$Mn$Grnumber;
    public static final StaticFieldLocation exact$Mninteger$Mnsqrt;
    public static final StaticFieldLocation make$Mnparameter;
    public static final StaticFieldLocation parameterize;
    public static final StaticFieldLocation call$Mnwith$Mnport;
    public static final StaticFieldLocation input$Mnport$Qu;
    public static final StaticFieldLocation output$Mnport$Qu;
    public static final StaticFieldLocation textual$Mnport$Qu;
    public static final StaticFieldLocation binary$Mnport$Qu;
    public static final StaticFieldLocation port$Qu;
    public static final StaticFieldLocation input$Mnport$Mnopen$Qu;
    public static final StaticFieldLocation output$Mnport$Mnopen$Qu;
    public static final StaticFieldLocation current$Mninput$Mnport;
    public static final StaticFieldLocation current$Mnoutput$Mnport;
    public static final StaticFieldLocation current$Mnerror$Mnport;
    public static final StaticFieldLocation write$Mnchar;
    public static final StaticFieldLocation write$Mnstring;
    public static final StaticFieldLocation write$Mnu8;
    public static final StaticFieldLocation write$Mnbytevector;
    public static final StaticFieldLocation open$Mninput$Mnstring;
    public static final StaticFieldLocation open$Mnoutput$Mnstring;
    public static final StaticFieldLocation get$Mnoutput$Mnstring;
    public static final StaticFieldLocation open$Mninput$Mnbytevector;
    public static final StaticFieldLocation open$Mnoutput$Mnbytevector;
    public static final StaticFieldLocation get$Mnoutput$Mnbytevector;
    public static final StaticFieldLocation flush$Mnoutput$Mnport;
    public static final StaticFieldLocation newline;
    public static final StaticFieldLocation eof$Mnobject$Qu;
    public static final StaticFieldLocation eof$Mnobject;
    public static final StaticFieldLocation char$Mnready$Qu;
    public static final StaticFieldLocation read$Mnchar;
    public static final StaticFieldLocation peek$Mnchar;
    public static final StaticFieldLocation read$Mnstring;
    public static final StaticFieldLocation read$Mnu8;
    public static final StaticFieldLocation peek$Mnu8;
    public static final StaticFieldLocation u8$Mnready$Qu;
    public static final StaticFieldLocation read$Mnbytevector;
    public static final StaticFieldLocation read$Mnbytevector$Ex;
    public static final StaticFieldLocation close$Mnport;
    public static final StaticFieldLocation close$Mninput$Mnport;
    public static final StaticFieldLocation close$Mnoutput$Mnport;
    public static final StaticFieldLocation read$Mnline;
    public static final StaticFieldLocation define$Mnsyntax;
    public static final StaticFieldLocation define;
    public static final StaticFieldLocation if;
    public static final StaticFieldLocation letrec;
    public static final StaticFieldLocation string$Qu;
    public static final StaticFieldLocation make$Mnstring;
    public static final StaticFieldLocation string$Mnlength;
    public static final StaticFieldLocation string$Mnref;
    public static final StaticFieldLocation string$Mnset$Ex;
    public static final StaticFieldLocation char$Eq$Qu;
    public static final StaticFieldLocation char$Ls$Qu;
    public static final StaticFieldLocation char$Gr$Qu;
    public static final StaticFieldLocation char$Ls$Eq$Qu;
    public static final StaticFieldLocation char$Gr$Eq$Qu;
    public static final StaticFieldLocation string$Eq$Qu;
    public static final StaticFieldLocation string$Ls$Qu;
    public static final StaticFieldLocation string$Gr$Qu;
    public static final StaticFieldLocation string$Ls$Eq$Qu;
    public static final StaticFieldLocation string$Gr$Eq$Qu;
    public static final StaticFieldLocation substring;
    public static final StaticFieldLocation string$Mn$Grlist;
    public static final StaticFieldLocation list$Mn$Grstring;
    public static final StaticFieldLocation string$Mncopy;
    public static final StaticFieldLocation string$Mncopy$Ex;
    public static final StaticFieldLocation string$Mnfill$Ex;
    public static final StaticFieldLocation string$Mnappend;
    public static final StaticFieldLocation string$Mnmap;
    public static final StaticFieldLocation string$Mnfor$Mneach;
    public static final StaticFieldLocation cond;
    public static final StaticFieldLocation and;
    public static final StaticFieldLocation or;
    public static final StaticFieldLocation let;
    public static final StaticFieldLocation let$St;
    public static final StaticFieldLocation do;
    public static final StaticFieldLocation else;
    public static final StaticFieldLocation $Dt$Dt$Dt;
    public static final StaticFieldLocation $Eq$Gr;
    public static final StaticFieldLocation _;
    public static final StaticFieldLocation unquote;
    public static final StaticFieldLocation unquote$Mnsplicing;
    public static final StaticFieldLocation when;
    public static final StaticFieldLocation unless;
    public static final StaticFieldLocation let$Mnvalues;
    public static final StaticFieldLocation let$St$Mnvalues;
    public static final StaticFieldLocation define$Mnvalues;
    public static final StaticFieldLocation vector$Qu;
    public static final StaticFieldLocation make$Mnvector;
    public static final StaticFieldLocation vector$Mnlength;
    public static final StaticFieldLocation vector$Mnset$Ex;
    public static final StaticFieldLocation vector$Mnref;
    public static final StaticFieldLocation vector$Mn$Grlist;
    public static final StaticFieldLocation list$Mn$Grvector;
    public static final StaticFieldLocation vector$Mn$Grstring;
    public static final StaticFieldLocation string$Mn$Grvector;
    public static final StaticFieldLocation vector$Mncopy;
    public static final StaticFieldLocation vector$Mncopy$Ex;
    public static final StaticFieldLocation vector$Mnfill$Ex;
    public static final StaticFieldLocation vector$Mnmap;
    public static final StaticFieldLocation vector$Mnfor$Mneach;
    public static final StaticFieldLocation define$Mnrecord$Mntype;
    public static final StaticFieldLocation $St;
    public static final StaticFieldLocation $Pl;
    public static final StaticFieldLocation $Mn;
    public static final StaticFieldLocation $Sl;
    public static final StaticFieldLocation $Ls;
    public static final StaticFieldLocation $Ls$Eq;
    public static final StaticFieldLocation $Eq;
    public static final StaticFieldLocation $Gr;
    public static final StaticFieldLocation $Gr$Eq;
    public static final StaticFieldLocation append;
    public static final StaticFieldLocation apply;
    public static final StaticFieldLocation begin;
    public static final StaticFieldLocation bytevector;
    public static final StaticFieldLocation call$Mnwith$Mncurrent$Mncontinuation;
    public static final StaticFieldLocation call$Mnwith$Mnvalues;
    public static final StaticFieldLocation call$Slcc;
    public static final StaticFieldLocation cond$Mnexpand;
    public static final StaticFieldLocation eq$Qu;
    public static final StaticFieldLocation equal$Qu;
    public static final StaticFieldLocation eqv$Qu;
    public static final StaticFieldLocation even$Qu;
    public static final StaticFieldLocation expt;
    public static final StaticFieldLocation floor$Mnquotient;
    public static final StaticFieldLocation floor$Mnremainder;
    public static final StaticFieldLocation for$Mneach;
    public static final StaticFieldLocation include;
    public static final StaticFieldLocation include$Mnci;
    public static final StaticFieldLocation lambda;
    public static final StaticFieldLocation let$Mnsyntax;
    public static final StaticFieldLocation letrec$Mnsyntax;
    public static final StaticFieldLocation list;
    public static final StaticFieldLocation map;
    public static final StaticFieldLocation modulo;
    public static final StaticFieldLocation not;
    public static final StaticFieldLocation odd$Qu;
    public static final StaticFieldLocation quasiquote;
    public static final StaticFieldLocation quote;
    public static final StaticFieldLocation quotient;
    public static final StaticFieldLocation remainder;
    public static final StaticFieldLocation set$Ex;
    public static final StaticFieldLocation string;
    public static final StaticFieldLocation syntax$Mnerror;
    public static final StaticFieldLocation syntax$Mnrules;
    public static final StaticFieldLocation truncate$Mnquotient;
    public static final StaticFieldLocation truncate$Mnremainder;
    public static final StaticFieldLocation vector;
    public static final StaticFieldLocation vector$Mnappend;
    public static final StaticFieldLocation letrec$St;
    public static base $instance;

    private static void $runBody$() {
        CallContext $ctx = CallContext.getInstance();
        Consumer $result = $ctx.consumer;
    }

    public static {
        $instance = new base();
        bytevector$Qu = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Qu");
        make$Mnbytevector = StaticFieldLocation.make("kawa.lib.bytevectors", "make$Mnbytevector");
        bytevector$Mnlength = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mnlength");
        bytevector$Mnu8$Mnref = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mnu8$Mnref");
        bytevector$Mnu8$Mnset$Ex = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mnu8$Mnset$Ex");
        bytevector$Mncopy = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mncopy");
        bytevector$Mncopy$Ex = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mncopy$Ex");
        bytevector$Mnappend = StaticFieldLocation.make("kawa.lib.bytevectors", "bytevector$Mnappend");
        utf8$Mn$Grstring = StaticFieldLocation.make("kawa.lib.bytevectors", "utf8$Mn$Grstring");
        string$Mn$Grutf8 = StaticFieldLocation.make("kawa.lib.bytevectors", "string$Mn$Grutf8");
        case = StaticFieldLocation.make("kawa.lib.case_syntax", "case");
        char$Qu = StaticFieldLocation.make("kawa.lib.characters", "char$Qu");
        char$Mn$Grinteger = StaticFieldLocation.make("kawa.lib.characters", "char$Mn$Grinteger");
        integer$Mn$Grchar = StaticFieldLocation.make("kawa.lib.characters", "integer$Mn$Grchar");
        with$Mnexception$Mnhandler = StaticFieldLocation.make("kawa.lib.exceptions", "with$Mnexception$Mnhandler");
        raise = StaticFieldLocation.make("kawa.lib.exceptions", "raise");
        raise$Mncontinuable = StaticFieldLocation.make("kawa.lib.exceptions", "raise$Mncontinuable");
        guard = StaticFieldLocation.make("kawa.lib.exceptions", "guard");
        error = StaticFieldLocation.make("kawa.lib.exceptions", "error");
        error$Mnobject$Qu = StaticFieldLocation.make("kawa.lib.exceptions", "error$Mnobject$Qu");
        error$Mnobject$Mnmessage = StaticFieldLocation.make("kawa.lib.exceptions", "error$Mnobject$Mnmessage");
        error$Mnobject$Mnirritants = StaticFieldLocation.make("kawa.lib.exceptions", "error$Mnobject$Mnirritants");
        read$Mnerror$Qu = StaticFieldLocation.make("kawa.lib.exceptions", "read$Mnerror$Qu");
        file$Mnerror$Qu = StaticFieldLocation.make("kawa.lib.exceptions", "file$Mnerror$Qu");
        pair$Qu = StaticFieldLocation.make("kawa.lib.lists", "pair$Qu");
        cons = StaticFieldLocation.make("kawa.lib.lists", "cons");
        null$Qu = StaticFieldLocation.make("kawa.lib.lists", "null$Qu");
        set$Mncar$Ex = StaticFieldLocation.make("kawa.lib.lists", "set$Mncar$Ex");
        set$Mncdr$Ex = StaticFieldLocation.make("kawa.lib.lists", "set$Mncdr$Ex");
        car = StaticFieldLocation.make("kawa.lib.lists", "car");
        cdr = StaticFieldLocation.make("kawa.lib.lists", "cdr");
        caar = StaticFieldLocation.make("kawa.lib.lists", "caar");
        cadr = StaticFieldLocation.make("kawa.lib.lists", "cadr");
        cdar = StaticFieldLocation.make("kawa.lib.lists", "cdar");
        cddr = StaticFieldLocation.make("kawa.lib.lists", "cddr");
        length = StaticFieldLocation.make("kawa.lib.lists", "length");
        reverse = StaticFieldLocation.make("kawa.lib.lists", "reverse");
        list$Mntail = StaticFieldLocation.make("kawa.lib.lists", "list$Mntail");
        list$Mnref = StaticFieldLocation.make("kawa.lib.lists", "list$Mnref");
        list$Mnset$Ex = StaticFieldLocation.make("kawa.lib.lists", "list$Mnset$Ex");
        list$Qu = StaticFieldLocation.make("kawa.lib.lists", "list$Qu");
        make$Mnlist = StaticFieldLocation.make("kawa.lib.lists", "make$Mnlist");
        memq = StaticFieldLocation.make("kawa.lib.lists", "memq");
        memv = StaticFieldLocation.make("kawa.lib.lists", "memv");
        member = StaticFieldLocation.make("kawa.lib.lists", "member");
        assq = StaticFieldLocation.make("kawa.lib.lists", "assq");
        assv = StaticFieldLocation.make("kawa.lib.lists", "assv");
        assoc = StaticFieldLocation.make("kawa.lib.lists", "assoc");
        list$Mncopy = StaticFieldLocation.make("kawa.lib.lists", "list$Mncopy");
        boolean$Qu = StaticFieldLocation.make("kawa.lib.misc", "boolean$Qu");
        boolean$Eq$Qu = StaticFieldLocation.make("kawa.lib.misc", "boolean$Eq$Qu");
        symbol$Qu = StaticFieldLocation.make("kawa.lib.misc", "symbol$Qu");
        symbol$Mn$Grstring = StaticFieldLocation.make("kawa.lib.misc", "symbol$Mn$Grstring");
        symbol$Eq$Qu = StaticFieldLocation.make("kawa.lib.misc", "symbol$Eq$Qu");
        string$Mn$Grsymbol = StaticFieldLocation.make("kawa.lib.misc", "string$Mn$Grsymbol");
        procedure$Qu = StaticFieldLocation.make("kawa.lib.misc", "procedure$Qu");
        values = StaticFieldLocation.make("kawa.lib.misc", "values");
        dynamic$Mnwind = StaticFieldLocation.make("kawa.lib.misc", "dynamic$Mnwind");
        features = StaticFieldLocation.make("kawa.lib.misc", "features");
        number$Qu = StaticFieldLocation.make("kawa.lib.numbers", "number$Qu");
        complex$Qu = StaticFieldLocation.make("kawa.lib.numbers", "complex$Qu");
        real$Qu = StaticFieldLocation.make("kawa.lib.numbers", "real$Qu");
        rational$Qu = StaticFieldLocation.make("kawa.lib.numbers", "rational$Qu");
        integer$Qu = StaticFieldLocation.make("kawa.lib.numbers", "integer$Qu");
        exact$Mninteger$Qu = StaticFieldLocation.make("kawa.lib.numbers", "exact$Mninteger$Qu");
        exact$Qu = StaticFieldLocation.make("kawa.lib.numbers", "exact$Qu");
        inexact$Qu = StaticFieldLocation.make("kawa.lib.numbers", "inexact$Qu");
        zero$Qu = StaticFieldLocation.make("kawa.lib.numbers", "zero$Qu");
        positive$Qu = StaticFieldLocation.make("kawa.lib.numbers", "positive$Qu");
        negative$Qu = StaticFieldLocation.make("kawa.lib.numbers", "negative$Qu");
        max = StaticFieldLocation.make("kawa.lib.numbers", "max");
        min = StaticFieldLocation.make("kawa.lib.numbers", "min");
        abs = StaticFieldLocation.make("kawa.lib.numbers", "abs");
        floor$Sl = StaticFieldLocation.make("kawa.lib.numbers", "floor$Sl");
        truncate$Sl = StaticFieldLocation.make("kawa.lib.numbers", "truncate$Sl");
        gcd = StaticFieldLocation.make("kawa.lib.numbers", "gcd");
        lcm = StaticFieldLocation.make("kawa.lib.numbers", "lcm");
        numerator = StaticFieldLocation.make("kawa.lib.numbers", "numerator");
        denominator = StaticFieldLocation.make("kawa.lib.numbers", "denominator");
        floor = StaticFieldLocation.make("kawa.lib.numbers", "floor");
        ceiling = StaticFieldLocation.make("kawa.lib.numbers", "ceiling");
        truncate = StaticFieldLocation.make("kawa.lib.numbers", "truncate");
        round = StaticFieldLocation.make("kawa.lib.numbers", "round");
        rationalize = StaticFieldLocation.make("kawa.lib.numbers", "rationalize");
        square = StaticFieldLocation.make("kawa.lib.numbers", "square");
        inexact = StaticFieldLocation.make("kawa.lib.numbers", "inexact");
        exact = StaticFieldLocation.make("kawa.lib.numbers", "exact");
        number$Mn$Grstring = StaticFieldLocation.make("kawa.lib.numbers", "number$Mn$Grstring");
        string$Mn$Grnumber = StaticFieldLocation.make("kawa.lib.numbers", "string$Mn$Grnumber");
        exact$Mninteger$Mnsqrt = StaticFieldLocation.make("kawa.lib.numbers", "exact$Mninteger$Mnsqrt");
        make$Mnparameter = StaticFieldLocation.make("kawa.lib.parameters", "make$Mnparameter");
        parameterize = StaticFieldLocation.make("kawa.lib.parameterize", "parameterize");
        call$Mnwith$Mnport = StaticFieldLocation.make("kawa.lib.ports", "call$Mnwith$Mnport");
        input$Mnport$Qu = StaticFieldLocation.make("kawa.lib.ports", "input$Mnport$Qu");
        output$Mnport$Qu = StaticFieldLocation.make("kawa.lib.ports", "output$Mnport$Qu");
        textual$Mnport$Qu = StaticFieldLocation.make("kawa.lib.ports", "textual$Mnport$Qu");
        binary$Mnport$Qu = StaticFieldLocation.make("kawa.lib.ports", "binary$Mnport$Qu");
        port$Qu = StaticFieldLocation.make("kawa.lib.ports", "port$Qu");
        input$Mnport$Mnopen$Qu = StaticFieldLocation.make("kawa.lib.ports", "input$Mnport$Mnopen$Qu");
        output$Mnport$Mnopen$Qu = StaticFieldLocation.make("kawa.lib.ports", "output$Mnport$Mnopen$Qu");
        current$Mninput$Mnport = StaticFieldLocation.make("kawa.lib.ports", "current$Mninput$Mnport");
        current$Mnoutput$Mnport = StaticFieldLocation.make("kawa.lib.ports", "current$Mnoutput$Mnport");
        current$Mnerror$Mnport = StaticFieldLocation.make("kawa.lib.ports", "current$Mnerror$Mnport");
        write$Mnchar = StaticFieldLocation.make("kawa.lib.ports", "write$Mnchar");
        write$Mnstring = StaticFieldLocation.make("kawa.lib.ports", "write$Mnstring");
        write$Mnu8 = StaticFieldLocation.make("kawa.lib.ports", "write$Mnu8");
        write$Mnbytevector = StaticFieldLocation.make("kawa.lib.ports", "write$Mnbytevector");
        open$Mninput$Mnstring = StaticFieldLocation.make("kawa.lib.ports", "open$Mninput$Mnstring");
        open$Mnoutput$Mnstring = StaticFieldLocation.make("kawa.lib.ports", "open$Mnoutput$Mnstring");
        get$Mnoutput$Mnstring = StaticFieldLocation.make("kawa.lib.ports", "get$Mnoutput$Mnstring");
        open$Mninput$Mnbytevector = StaticFieldLocation.make("kawa.lib.ports", "open$Mninput$Mnbytevector");
        open$Mnoutput$Mnbytevector = StaticFieldLocation.make("kawa.lib.ports", "open$Mnoutput$Mnbytevector");
        get$Mnoutput$Mnbytevector = StaticFieldLocation.make("kawa.lib.ports", "get$Mnoutput$Mnbytevector");
        flush$Mnoutput$Mnport = StaticFieldLocation.make("kawa.lib.ports", "flush$Mnoutput$Mnport");
        newline = StaticFieldLocation.make("kawa.lib.ports", "newline");
        eof$Mnobject$Qu = StaticFieldLocation.make("kawa.lib.ports", "eof$Mnobject$Qu");
        eof$Mnobject = StaticFieldLocation.make("kawa.lib.ports", "eof$Mnobject");
        char$Mnready$Qu = StaticFieldLocation.make("kawa.lib.ports", "char$Mnready$Qu");
        read$Mnchar = StaticFieldLocation.make("kawa.lib.ports", "read$Mnchar");
        peek$Mnchar = StaticFieldLocation.make("kawa.lib.ports", "peek$Mnchar");
        read$Mnstring = StaticFieldLocation.make("kawa.lib.ports", "read$Mnstring");
        read$Mnu8 = StaticFieldLocation.make("kawa.lib.ports", "read$Mnu8");
        peek$Mnu8 = StaticFieldLocation.make("kawa.lib.ports", "peek$Mnu8");
        u8$Mnready$Qu = StaticFieldLocation.make("kawa.lib.ports", "u8$Mnready$Qu");
        read$Mnbytevector = StaticFieldLocation.make("kawa.lib.ports", "read$Mnbytevector");
        read$Mnbytevector$Ex = StaticFieldLocation.make("kawa.lib.ports", "read$Mnbytevector$Ex");
        close$Mnport = StaticFieldLocation.make("kawa.lib.ports", "close$Mnport");
        close$Mninput$Mnport = StaticFieldLocation.make("kawa.lib.ports", "close$Mninput$Mnport");
        close$Mnoutput$Mnport = StaticFieldLocation.make("kawa.lib.ports", "close$Mnoutput$Mnport");
        read$Mnline = StaticFieldLocation.make("kawa.lib.ports", "read$Mnline");
        define$Mnsyntax = StaticFieldLocation.make("kawa.lib.prim_syntax", "define$Mnsyntax");
        define = StaticFieldLocation.make("kawa.lib.prim_syntax", "define");
        if = StaticFieldLocation.make("kawa.lib.prim_syntax", "if");
        letrec = StaticFieldLocation.make("kawa.lib.prim_syntax", "letrec");
        string$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Qu");
        make$Mnstring = StaticFieldLocation.make("kawa.lib.strings", "make$Mnstring");
        string$Mnlength = StaticFieldLocation.make("kawa.lib.strings", "string$Mnlength");
        string$Mnref = StaticFieldLocation.make("kawa.lib.strings", "string$Mnref");
        string$Mnset$Ex = StaticFieldLocation.make("kawa.lib.strings", "string$Mnset$Ex");
        char$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "char$Eq$Qu");
        char$Ls$Qu = StaticFieldLocation.make("kawa.lib.strings", "char$Ls$Qu");
        char$Gr$Qu = StaticFieldLocation.make("kawa.lib.strings", "char$Gr$Qu");
        char$Ls$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "char$Ls$Eq$Qu");
        char$Gr$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "char$Gr$Eq$Qu");
        string$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Eq$Qu");
        string$Ls$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Ls$Qu");
        string$Gr$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Gr$Qu");
        string$Ls$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Ls$Eq$Qu");
        string$Gr$Eq$Qu = StaticFieldLocation.make("kawa.lib.strings", "string$Gr$Eq$Qu");
        substring = StaticFieldLocation.make("kawa.lib.strings", "substring");
        string$Mn$Grlist = StaticFieldLocation.make("kawa.lib.strings", "string$Mn$Grlist");
        list$Mn$Grstring = StaticFieldLocation.make("kawa.lib.strings", "list$Mn$Grstring");
        string$Mncopy = StaticFieldLocation.make("kawa.lib.strings", "string$Mncopy");
        string$Mncopy$Ex = StaticFieldLocation.make("kawa.lib.strings", "string$Mncopy$Ex");
        string$Mnfill$Ex = StaticFieldLocation.make("kawa.lib.strings", "string$Mnfill$Ex");
        string$Mnappend = StaticFieldLocation.make("kawa.lib.strings", "string$Mnappend");
        string$Mnmap = StaticFieldLocation.make("kawa.lib.strings", "string$Mnmap");
        string$Mnfor$Mneach = StaticFieldLocation.make("kawa.lib.strings", "string$Mnfor$Mneach");
        cond = StaticFieldLocation.make("kawa.lib.std_syntax", "cond");
        and = StaticFieldLocation.make("kawa.lib.std_syntax", "and");
        or = StaticFieldLocation.make("kawa.lib.std_syntax", "or");
        let = StaticFieldLocation.make("kawa.lib.std_syntax", "let");
        let$St = StaticFieldLocation.make("kawa.lib.std_syntax", "let$St");
        do = StaticFieldLocation.make("kawa.lib.std_syntax", "do");
        else = StaticFieldLocation.make("kawa.lib.std_syntax", "else");
        $Dt$Dt$Dt = StaticFieldLocation.make("kawa.lib.std_syntax", "$Dt$Dt$Dt");
        $Eq$Gr = StaticFieldLocation.make("kawa.lib.std_syntax", "$Eq$Gr");
        _ = StaticFieldLocation.make("kawa.lib.std_syntax", "_");
        unquote = StaticFieldLocation.make("kawa.lib.std_syntax", "unquote");
        unquote$Mnsplicing = StaticFieldLocation.make("kawa.lib.std_syntax", "unquote$Mnsplicing");
        when = StaticFieldLocation.make("kawa.lib.syntax", "when");
        unless = StaticFieldLocation.make("kawa.lib.syntax", "unless");
        let$Mnvalues = StaticFieldLocation.make("kawa.lib.syntax", "let$Mnvalues");
        let$St$Mnvalues = StaticFieldLocation.make("kawa.lib.syntax", "let$St$Mnvalues");
        define$Mnvalues = StaticFieldLocation.make("kawa.lib.syntax", "define$Mnvalues");
        vector$Qu = StaticFieldLocation.make("kawa.lib.vectors", "vector$Qu");
        make$Mnvector = StaticFieldLocation.make("kawa.lib.vectors", "make$Mnvector");
        vector$Mnlength = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnlength");
        vector$Mnset$Ex = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnset$Ex");
        vector$Mnref = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnref");
        vector$Mn$Grlist = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mn$Grlist");
        list$Mn$Grvector = StaticFieldLocation.make("kawa.lib.vectors", "list$Mn$Grvector");
        vector$Mn$Grstring = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mn$Grstring");
        string$Mn$Grvector = StaticFieldLocation.make("kawa.lib.vectors", "string$Mn$Grvector");
        vector$Mncopy = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mncopy");
        vector$Mncopy$Ex = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mncopy$Ex");
        vector$Mnfill$Ex = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnfill$Ex");
        vector$Mnmap = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnmap");
        vector$Mnfor$Mneach = StaticFieldLocation.make("kawa.lib.vectors", "vector$Mnfor$Mneach");
        define$Mnrecord$Mntype = StaticFieldLocation.make("kawa.lib.DefineRecordType", "define$Mnrecord$Mntype");
        $St = StaticFieldLocation.make("gnu.kawa.functions.MultiplyOp", "$St");
        $Pl = StaticFieldLocation.make("gnu.kawa.functions.AddOp", "$Pl");
        $Mn = StaticFieldLocation.make("gnu.kawa.functions.AddOp", "$Mn");
        $Sl = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "$Sl");
        $Ls = StaticFieldLocation.make("kawa.standard.Scheme", "numLss");
        $Ls$Eq = StaticFieldLocation.make("kawa.standard.Scheme", "numLEq");
        $Eq = StaticFieldLocation.make("kawa.standard.Scheme", "numEqu");
        $Gr = StaticFieldLocation.make("kawa.standard.Scheme", "numGrt");
        $Gr$Eq = StaticFieldLocation.make("kawa.standard.Scheme", "numGEq");
        append = StaticFieldLocation.make("kawa.standard.append", "append");
        apply = StaticFieldLocation.make("kawa.standard.Scheme", "apply");
        begin = StaticFieldLocation.make("kawa.standard.begin", "begin");
        bytevector = StaticFieldLocation.make("gnu.kawa.lispexpr.LangObjType", "u8vectorType");
        call$Mnwith$Mncurrent$Mncontinuation = StaticFieldLocation.make("gnu.kawa.functions.CallCC", "callcc");
        call$Mnwith$Mnvalues = StaticFieldLocation.make("gnu.kawa.functions.CallWithValues", "callWithValues");
        call$Slcc = StaticFieldLocation.make("gnu.kawa.functions.CallCC", "callcc");
        cond$Mnexpand = StaticFieldLocation.make("kawa.standard.IfFeature", "condExpand");
        eq$Qu = StaticFieldLocation.make("kawa.standard.Scheme", "isEq");
        equal$Qu = StaticFieldLocation.make("kawa.standard.Scheme", "isEqual");
        eqv$Qu = StaticFieldLocation.make("kawa.standard.Scheme", "isEqv");
        even$Qu = StaticFieldLocation.make("kawa.standard.Scheme", "isEven");
        expt = StaticFieldLocation.make("kawa.standard.expt", "expt");
        floor$Mnquotient = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "floorQuotient");
        floor$Mnremainder = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "modulo");
        for$Mneach = StaticFieldLocation.make("kawa.standard.Scheme", "forEach");
        include = StaticFieldLocation.make("kawa.standard.Include", "include");
        include$Mnci = StaticFieldLocation.make("kawa.standard.Include", "includeCi");
        lambda = StaticFieldLocation.make("kawa.standard.SchemeCompilation", "lambda");
        let$Mnsyntax = StaticFieldLocation.make("kawa.standard.let_syntax", "let_syntax");
        letrec$Mnsyntax = StaticFieldLocation.make("kawa.standard.let_syntax", "letrec_syntax");
        list = StaticFieldLocation.make("gnu.kawa.lispexpr.LangObjType", "listType");
        map = StaticFieldLocation.make("kawa.standard.Scheme", "map");
        modulo = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "modulo");
        not = StaticFieldLocation.make("kawa.standard.Scheme", "not");
        odd$Qu = StaticFieldLocation.make("kawa.standard.Scheme", "isOdd");
        quasiquote = StaticFieldLocation.make("kawa.lang.Quote", "quasiQuote");
        quote = StaticFieldLocation.make("kawa.lang.Quote", "plainQuote");
        quotient = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "quotient");
        remainder = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "remainder");
        set$Ex = StaticFieldLocation.make("kawa.standard.set_b", "set");
        string = StaticFieldLocation.make("gnu.kawa.lispexpr.LangObjType", "stringType");
        syntax$Mnerror = StaticFieldLocation.make("kawa.standard.syntax_error", "syntax_error");
        syntax$Mnrules = StaticFieldLocation.make("kawa.standard.syntax_rules", "syntax_rules");
        truncate$Mnquotient = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "quotient");
        truncate$Mnremainder = StaticFieldLocation.make("gnu.kawa.functions.DivideOp", "remainder");
        vector = StaticFieldLocation.make("gnu.kawa.lispexpr.LangObjType", "vectorType");
        vector$Mnappend = StaticFieldLocation.make("kawa.standard.vector_append", "vectorAppend");
        letrec$St = StaticFieldLocation.make("kawa.lib.prim_syntax", "letrec");
        base.$runBody$();
    }

    public base() {
        ModuleInfo.register(this);
    }
}

