/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2018 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 *
 */
package de.appwerft.feitian;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollFunction;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.TiApplication;

import com.ftsafe.DK;
import com.ftsafe.Utility;
import com.ftsafe.readerScheme.FTException;
import com.ftsafe.readerScheme.FTReader;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.content.Context;
import android.os.Handler;
import android.os.Message;

@Kroll.module(name = "Feitiansmartcardreader", id = "de.appwerft.feitian", propertyAccessors = { "onConnect",
		"onError" })
public class FeitiansmartcardreaderModule extends KrollModule {

	// Standard Debugging variables
	public static final String LCAT = "FeitianModule";

	KrollDict callbacks = new KrollDict();
	//
	private FTReader ftReader;
	private int testi = 0;

	private Context ctx = TiApplication.getInstance().getApplicationContext();

	Tpcsc tpcsc = null;

	ArrayList<BluetoothDevice> arrayForBlueToothDevice = new ArrayList<BluetoothDevice>();
	ArrayList<DeviceProxy> arrayForBlueToothDeviceProxy = new ArrayList<DeviceProxy>();
	
	// @Kroll.constant
	// public static final String EXTERNAL_NAME = value;

	public FeitiansmartcardreaderModule() {
		super();
	}

	@Kroll.onAppCreate
	public static void onAppCreate(TiApplication app) {

	}

	@Kroll.method
	public void connect() { // jar mode, BLE
		ftReader = new FTReader(ctx, mHandler, DK.FTREADER_TYPE_BT4);
	}

	@Kroll.method
	public KrollDict getType() { 
		KrollDict res= new KrollDict();
		try {
			res.put("manufacturer", new String(ftReader.readerGetManufacturer())/*Utility.bytes2HexStr(manufacturer)*/);
			res.put("hardwareinfo", Utility.bytes2HexStr(ftReader.readerGetHardwareInfo()));
			res.put("readername", new String(ftReader.readerGetReaderName()));
			res.put("serialnumber", Utility.bytes2HexStr(ftReader.readerGetSerialNumber()));
			return res;
		} catch (FTException e) {
			e.printStackTrace();
		}
		return null;
	}


	
	
	private Handler mHandler = new Handler() {
		@Override
		public void handleMessage(Message msg) {
			super.handleMessage(msg);
			KrollDict event = new KrollDict();
			switch (msg.what) {
			case -1:
				return;
			case 0:
				Log.d(LCAT, msg.obj.toString());
				break;
			case DK.USB_IN:
				break;
			case DK.USB_OUT:
				break;
			case DK.PCSCSERVER_LOG:
				break;
			case DK.USB_LOG:
				break;
			case DK.BT3_LOG:
				// textView.append("[BT3Log]:"+msg.obj+"\n");
				break;
			case DK.BT4_LOG:
				// textView.append("[BT4Log]:"+msg.obj+"\n");
				break;
			case DK.FTREADER_LOG:
				// textView.append("[FTReaderLog]:"+msg.obj+"\n");
				break;
			case DK.CCIDSCHEME_LOG:
				// textView.append("[CCIDSchemeLog]:"+msg.obj+"\n");
				break;
			
			case DK.BT3_NEW:
				BluetoothDevice dev1 = (BluetoothDevice) msg.obj;
				Log.d(LCAT, "[BT3_NEW]:" + dev1.getName() + "\n");
				event.put("type","bt3");
				event.put("device",new DeviceProxy(dev1));
				arrayForBlueToothDevice.add(dev1);
				break;

			case DK.BT4_NEW:
				BluetoothDevice dev2 = (BluetoothDevice) msg.obj;
				arrayForBlueToothDevice.add(dev2);
				event.put("type","bt4");
				event.put("device",new DeviceProxy(dev2));
				break;
			case DK.BT4_ACL_DISCONNECTED:
				BluetoothDevice dev3 = (BluetoothDevice) msg.obj;
				break;
			default:
				if ((msg.what & DK.CARD_IN_MASK) == DK.CARD_IN_MASK) {
					return;
				} else if ((msg.what & DK.CARD_OUT_MASK) == DK.CARD_OUT_MASK) {
					return;
				}
				break;
			}
			if (hasListeners("onConnected")) {
				fireEvent("onConnected",event);
			}
		}
	};

	private void readCallbacks() {

		Iterator it = getProperties().entrySet().iterator();
		while (it.hasNext()) {
			Map.Entry pair = (Map.Entry) it.next();
			if (pair.getValue() instanceof KrollFunction) {
				callbacks.put((String) pair.getKey(), pair.getValue());
			}
			it.remove(); // avoids a ConcurrentModificationException
		}

	}
}
